#!/system/bin/sh
# ==============================================================================
# f2fsopt - F2FS/EXT4 ä¼˜åŒ–å™¨ - è‡ªåŠ¨ Trim + GC
# ==============================================================================

# ==============================================================================
# é…ç½®åŒºåŸŸ
# ==============================================================================

# åŠŸèƒ½å¼€å…³
readonly ENABLE_MAGISK_UI=true      # æ›´æ–°æ¨¡å—æè¿°
readonly ENABLE_SMART_GC=true       # å¥åº·åˆ†åŒºè·³è¿‡GC
readonly ENABLE_SMART_TRIM=true     # å¥åº·åˆ†åŒºè·³è¿‡Trim
readonly STOP_ON_SCREEN_ON=false    # äº®å±ä¸­æ–­
readonly ONLY_CHARGING=false        # ä»…å……ç”µæ—¶è¿è¡Œ

# GC ç­–ç•¥
readonly ENABLE_TURBO_GC=true       # å¯ç”¨æé€ŸGC
readonly GC_MODE_PREF="1"           # GCæ¨¡å¼: 1=å‰å° 2=åå° (æ³¨: å†…æ ¸å¯èƒ½è¿”å› 3/5 ç­‰æ‰©å±•æšä¸¾ï¼Œå±æ­£å¸¸)
readonly GC_DIRTY_MIN=200           # è„æ®µé˜ˆå€¼
readonly GC_TURBO_SLEEP=50          # æé€ŸGCç¡çœ (ms)
readonly GC_SAFE_SLEEP=500          # å®‰å…¨GCç¡çœ (ms)
readonly GC_MAX_SEC=500             # æœ€å¤§è¿è¡Œæ—¶é•¿(ç§’)
readonly GC_STABLE_CNT=8           # ç¨³å®šè®¡æ•°
readonly TRIM_TIMEOUT=500           # Trimè¶…æ—¶(ç§’)
readonly GC_POLL=1                  # è½®è¯¢é—´éš”(ç§’)

# æ‰«ææ€§èƒ½è¯Šæ–­
readonly DEBUG_SCAN=1               # æŒ‚è½½ç‚¹æ‰«æè¯Šæ–­: 0=ç¦ç”¨ 1=å¯ç”¨
readonly SLOW_MOUNT_THRESHOLD=1000  # æ¯«ç§’ï¼Œè¶…è¿‡æ­¤å€¼è¾“å‡ºä¿¡æ¯
readonly VERY_SLOW_THRESHOLD=1500  # æ¯«ç§’ï¼Œè¶…è¿‡æ­¤å€¼è¾“å‡ºè­¦å‘Š

# ç³»ç»Ÿè·¯å¾„
# æ³¨æ„: å¦‚æœä¿®æ”¹ LOCK_DIRï¼Œè¯·åŠ¡å¿…åŒæ­¥ä¿®æ”¹ action.sh ä¸­çš„ F2FSOPT_LOCK_DIR
readonly LOCK_DIR="/data/local/tmp/f2fsopt.lock.d"
readonly LOCK_PID_FILE="$LOCK_DIR/pid"
readonly WAKE_LOCK_ID="f2fsopt_lck"

# å¿½ç•¥è·¯å¾„å‰ç¼€ï¼ˆç»Ÿä¸€é»‘åå•é…ç½®ï¼‰
readonly IGNORE_PREFIXES="
/storage /mnt /apex /bionic /system /vendor /product /odm /dev /sys /proc
/acct /config /debug_ramdisk /data_mirror /linkerconfig /postinstall
/metadata /oem /lost+found /system_ext /vendor /my_product /odm /bin /sbin
/data/user_de /data/data /data/adb
"

# ä¾èµ–å·¥å…·åˆ—è¡¨
readonly REQUIRED_TOOLS="stat readlink fstrim timeout ls mkdir rm rmdir sleep date"

# ==============================================================================
# ç¯å¢ƒåˆå§‹åŒ–
# ==============================================================================

if [ -L "$0" ]; then
    _script_real=$(readlink -f "$0" 2>/dev/null)
    [ -n "$_script_real" ] && MODDIR="${_script_real%/*}" || MODDIR="${0%/*}"
else
    MODDIR="${0%/*}"
fi

readonly SCRIPT_NAME="${0##*/}"
START_TIME=$(date +%s)

# ç»Ÿè®¡å˜é‡
TOTAL_TRIM_KB=0
TOTAL_GC_SEGS=0
COUNT_GC_RUN=0
COUNT_GC_SKIP=0
COUNT_TRIM_RUN=0
COUNT_TRIM_SKIP=0
COUNT_TRIM_ZERO=0
COUNT_SCREEN_SKIP=0
COUNT_SYS_API=0
LIST_FAIL=""
EXIT_CODE=0
SM_FSTRIM_CALLED=false  # sm fstrim å…¨å±€è°ƒç”¨æ ‡è®°

# å¹¶å‘æ§åˆ¶å˜é‡åˆå§‹åŒ–
HAS_ACQUIRED_WAKELOCK=false
ACTIVE_GC_NODE=""
ACTIVE_SLEEP_NODE=""
RESTORE_GC_VAL=""
RESTORE_SLEEP_VAL=""

export LC_ALL=C

# æŸ¥æ‰¾ Busybox
BB_PATH=""
for p in "/data/adb/magisk/busybox" "/data/adb/ksu/bin/busybox" "/data/adb/ap/bin/busybox" "/sbin/.magisk/busybox" "/system/xbin/busybox" "/system/bin/busybox" "$(command -v busybox)"; do
    if [ -x "$p" ]; then 
        BB_PATH="$p"
        export PATH="${BB_PATH%/*}:$PATH"
        break
    fi
done

# 1. å®šä¹‰busyboxä»£ç† (å…¨ä»£ç†æ¨¡å¼ + å®‰å…¨è¿‡æ»¤)
init_command_proxy() {
    # åŸºç¡€æ£€æŸ¥
    if [ -z "$BB_PATH" ] || [ ! -x "$BB_PATH" ]; then return 1; fi
    
    local _cmd _bb_caps _type_out
    
    _bb_caps=$("$BB_PATH" --list 2>/dev/null)
    
    # é¢„å®šä¹‰ Shell æ ¸å¿ƒå‘½ä»¤é»‘åå•ï¼Œé¿å…é‡å¤ type è°ƒç”¨
    local _shell_builtins="echo cd pwd exit test true false [ : . break continue eval exec export readonly return set shift times trap unset"
    
    # 3. éå† Busybox æ”¯æŒçš„æ¯ä¸ªå‘½ä»¤
    for _cmd in $_bb_caps; do
        # [è¿‡æ»¤å™¨ A] å­—ç¬¦åˆæ³•æ€§æ£€æŸ¥
        case "$_cmd" in
            *[!a-zA-Z0-9_.-]*) continue ;;  # æ’é™¤ç‰¹æ®Šå­—ç¬¦
            [0-9]*) continue ;;              # æ’é™¤æ•°å­—å¼€å¤´
        esac
        
        # [è¿‡æ»¤å™¨ B] Shell æ ¸å¿ƒå‘½ä»¤é»‘åå•ï¼ˆå¿«é€Ÿè·¯å¾„ï¼‰
        case " $_shell_builtins " in
            *" $_cmd "*) continue ;;
        esac
        
        # [è¿‡æ»¤å™¨ C] type æ£€æµ‹å…œåº•ï¼ˆä»…å¯¹é»‘åå•å¤–çš„å‘½ä»¤ï¼‰
        _type_out=$(type "$_cmd" 2>/dev/null)
        case "$_type_out" in
            *builtin*|*reserved*|*keyword*) continue ;;
        esac
        
        # 4. æ‰§è¡Œä»£ç†æ³¨å†Œï¼ˆå®‰å…¨å‘½ä»¤ï¼‰
        eval "$_cmd() { '$BB_PATH' $_cmd \"\$@\"; }"
    done
    
    # 5. åˆ·æ–° Shell å“ˆå¸Œè¡¨
    hash -r 2>/dev/null || true
}

# æ‰§è¡Œä»£ç†åˆå§‹åŒ–
init_command_proxy

HAS_TIMEOUT=false
HAS_STAT=false
HAS_FSTRIM=false

# æ£€æµ‹å¯ç”¨æ€§ï¼ˆä»£ç†å±‚å·²å¼ºåˆ¶åˆ›å»ºï¼Œæ­¤å¤„ä»…æ£€æµ‹æœ€ç»ˆå¯ç”¨æ€§ï¼‰
command -v timeout >/dev/null 2>&1 && HAS_TIMEOUT=true
command -v stat >/dev/null 2>&1 && HAS_STAT=true
command -v fstrim >/dev/null 2>&1 && HAS_FSTRIM=true

# ==============================================================================
# å‘½ä»¤è¡Œæ¥å£
# ==============================================================================

show_help() {
    printf "ç”¨æ³•: %s [é€‰é¡¹] [è·¯å¾„...]\n" "$SCRIPT_NAME"
    printf "åŠŸèƒ½: F2FS/EXT4 åˆ†åŒºæ™ºèƒ½ä¼˜åŒ– (Trim + GC)\n\n"
    printf "é€‰é¡¹:\n"
    printf "  -t, --fstrim   ä»…æ‰§è¡Œ Trim\n"
    printf "  -g, --gc       ä»…æ‰§è¡Œ GC\n"
    printf "  -s, --system   å¼ºåˆ¶ä½¿ç”¨ç³»ç»Ÿ API (sm)\n"
    printf "  -h, --help     æ˜¾ç¤ºå¸®åŠ©\n\n"
    printf "è·¯å¾„å‚æ•°:\n"
    printf "  ä¸æŒ‡å®šè·¯å¾„ - è‡ªåŠ¨æ‰«ææ‰€æœ‰F2FS/EXT4åˆ†åŒº\n"
    printf "  æŒ‡å®šè·¯å¾„   - ä»…ä¼˜åŒ–æŒ‡å®šæŒ‚è½½ç‚¹\n\n"
    printf "ç¤ºä¾‹:\n"
    printf "  %s                    # è‡ªåŠ¨æ‰«æï¼Œæ‰§è¡ŒTrim+GC\n" "$SCRIPT_NAME"
    printf "  %s -t                 # è‡ªåŠ¨æ‰«æï¼Œä»…Trim\n" "$SCRIPT_NAME"
    printf "  %s -g /data           # ä»…å¯¹/dataæ‰§è¡ŒGC\n" "$SCRIPT_NAME"
    printf "  %s /data /cache       # ä»…ä¼˜åŒ–/dataå’Œ/cache\n" "$SCRIPT_NAME"
}

TRIM=false; GC=false; USE_SYSTEM_API=false; MANUAL_TARGETS=""
while [ "$#" -gt 0 ]; do
    case "$1" in
        -t|--fstrim) TRIM=true ;;
        -g|--gc)     GC=true ;;
        -s|--system) USE_SYSTEM_API=true ;;
        -h|--help)   show_help; exit 0 ;;
        *)           MANUAL_TARGETS="$MANUAL_TARGETS $1" ;;
    esac
    shift
done
if [ "$TRIM" = false ] && [ "$GC" = false ]; then TRIM=true; GC=true; fi

# ==============================================================================
# æ ¸å¿ƒå‡½æ•°
# ==============================================================================

is_integer() { case "$1" in ''|*[!0-9]*) return 1 ;; *) return 0 ;; esac }

LOG_TIMESTAMP=""
LOG_TIMESTAMP_EPOCH=0
update_log_timestamp() {
    local _now=$(date +%s) _elapsed=0
    if is_integer "$_now" && is_integer "$LOG_TIMESTAMP_EPOCH"; then _elapsed=$((_now - LOG_TIMESTAMP_EPOCH)); else _elapsed=999; fi
    if [ "$_elapsed" -ge 5 ] || [ -z "$LOG_TIMESTAMP" ]; then
        LOG_TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
        is_integer "$_now" && LOG_TIMESTAMP_EPOCH=$_now
    fi
}
log_msg() { update_log_timestamp; printf '%s %s\n' "$LOG_TIMESTAMP" "$1" >&2; }

# è·å–æ¯«ç§’æ—¶é—´æˆ³
get_timestamp_ms() {
    local _sec _nsec _ms
    # ä¼˜å…ˆä½¿ç”¨é«˜ç²¾åº¦æ—¶é—´
    if read -r _sec _nsec < /proc/uptime 2>/dev/null; then
        # è½¬æ¢çº³ç§’ä¸ºæ¯«ç§’ï¼šå»æ‰å°æ•°ç‚¹ï¼Œå–å‰ä¸‰ä½
        _nsec="${_nsec}000"  # è¡¥é½ä½æ•°
        _ms="${_nsec%%.*}"   # å»å°æ•°
        _ms="${_ms:0:3}"     # å–å‰3ä½
        printf '%d%03d\n' "${_sec%%.*}" "${_ms:-0}"
    else
        # å›é€€ï¼šç§’çº§ç²¾åº¦
        printf '%d000\n' "$(date +%s)"
    fi
}

read_first_line() {
    eval "$1=''"
    [ -r "$2" ] 2>/dev/null || return 1
    local _tmp_line=""
    read -r _tmp_line < "$2" 2>/dev/null || return 1
    eval "$1=\$_tmp_line"
}

decode_path() {
    local _path="$1"
    if [ "${_path#*\\040}" != "$_path" ]; then printf '%b' "$_path"; else printf '%s\n' "$_path"; fi
}

is_path_ignored() {
    local _path="$1" _prefix
    for _prefix in $IGNORE_PREFIXES; do
        case "$_path" in "$_prefix"|"${_prefix}"/*) return 0 ;; esac
    done
    return 1
}

# æ›´æ–°æ¨¡å—æè¿°
update_magisk_ui() {
    local _msg="$1"
    [ "$ENABLE_MAGISK_UI" = true ] || return 0
    [ -f "$MODDIR/module.prop" ] || return 0
    local _final_msg="$_msg ğŸ•’æ—¥æœŸ:$(date "+%Y-%m-%d %H:%M:%S")"
    local _tmp="$MODDIR/module.prop.tmp"
    {
        while IFS= read -r _line || [ -n "$_line" ]; do
            case "$_line" in
                description=*)
                    printf 'description=%s\n' "$_final_msg"
                    ;;
                *)
                    printf '%s\n' "$_line"
                    ;;
            esac
        done < "$MODDIR/module.prop"
    } > "$_tmp" 2>/dev/null && mv "$_tmp" "$MODDIR/module.prop" 2>/dev/null
    # æ¸…ç†å¤±è´¥æ®‹ç•™
    rm -f "$_tmp" 2>/dev/null
}

# è§£æè®¾å¤‡è·¯å¾„ï¼šå¤„ç†ç¬¦å·é“¾æ¥
resolve_dev_path() {
    local _path="$1" _limit=10 _target _dir _out
    
    # å¿«é€Ÿè·¯å¾„: readlink -f
    _out=$(readlink -f "$_path" 2>/dev/null)
    [ -e "$_out" ] && { printf '%s\n' "$_out"; return 0; }
    
    # å›é€€è·¯å¾„: æ‰‹åŠ¨é€’å½’è§£æ
    while [ -L "$_path" ] && [ "$_limit" -gt 0 ]; do
        _target=$(readlink "$_path" 2>/dev/null)
        # å…¼å®¹æ€§å›é€€: ls -l è§£æ
        if [ -z "$_target" ]; then
            local _ls_out=$(ls -l "$_path" 2>/dev/null)
            case "$_ls_out" in *" -> "*) _target="${_ls_out##* -> }" ;; *) break ;; esac
        fi
        
        _target="${_target## }"; _target="${_target%% }"
        [ -z "$_target" ] && break
        
        case "$_target" in 
            /*) _path="$_target" ;;
            *) 
                _dir="${_path%/*}"
                [ "$_dir" = "$_path" ] && _dir="."
                _path="$_dir/$_target"
            ;;
        esac
        _limit=$((_limit - 1))
    done
    
    # ç®€å•çš„è§„èŒƒåŒ– (ç§»é™¤ /./ï¼Œå¾ªç¯ç›´åˆ°ä¸åŒ…å«æ­¤æ¨¡å¼)
    while case "$_path" in */./*) true;; *) false;; esac; do
        _path="${_path%%/./*}/${_path#*/./}"
    done
    [ -e "$_path" ] && printf '%s\n' "$_path"
}

# è·å–æŒ‚è½½ç‚¹è®¾å¤‡ID
get_mountinfo_id() {
    local _target_mnt="$1" _decoded_mnt
    [ -r "/proc/self/mountinfo" ] || return 1
    while read -r _id _par _devid _root _mnt _rest; do
        _decoded_mnt=$(decode_path "$_mnt")
        if [ "$_decoded_mnt" = "$_target_mnt" ]; then printf '%s\n' "$_devid"; return 0; fi
    done < /proc/self/mountinfo
    return 1
}

# è·å–è®¾å¤‡å”¯ä¸€æŒ‡çº¹
get_device_fingerprint() {
    local _path="$1" _mnt="$2" _real_path _bname _id=""
    
    _real_path=$(resolve_dev_path "$_path")
    
    # ä¼˜å…ˆçº§ 1: Stat
    if [ "$HAS_STAT" = true ] && [ -e "$_real_path" ]; then
        local _maj _min _stat_out
        
        if [ "$HAS_TIMEOUT" = true ]; then
            # æ™ºèƒ½è§£åŒ…ï¼šæ£€æµ‹ timeout å’Œ stat æ˜¯å¦ä¸ºä»£ç†å‡½æ•°
            local _timeout_cmd="timeout" _stat_cmd="stat" _type_out
            
            _type_out=$(type timeout 2>/dev/null)
            case "$_type_out" in
                *function*) [ -n "$BB_PATH" ] && _timeout_cmd="$BB_PATH timeout" ;;
            esac
            
            _type_out=$(type stat 2>/dev/null)
            case "$_type_out" in
                *function*) [ -n "$BB_PATH" ] && _stat_cmd="$BB_PATH stat" ;;
            esac
            
            # æ‰§è¡Œ (ä¸åŠ å¼•å·ï¼Œå…è®¸ç©ºæ ¼åˆ†è¯)
            _stat_out=$($_timeout_cmd 2 $_stat_cmd -L -c '%t %T' "$_real_path" 2>/dev/null)
        else
            _stat_out=$(stat -L -c '%t %T' "$_real_path" 2>/dev/null)
        fi
        
        if [ -n "$_stat_out" ]; then
            _maj="${_stat_out%% *}"
            _min="${_stat_out##* }"
            case "$_maj$_min" in *[!0-9a-fA-F]*) ;; *)
                printf "%d:%d" "0x$_maj" "0x$_min"
                return 0
            ;; esac
        fi
    fi

    # ä¼˜å…ˆçº§ 2: Mountinfo
    if [ -n "$_mnt" ]; then
        _id=$(get_mountinfo_id "$_mnt")
        if [ -n "$_id" ]; then printf '%s\n' "$_id"; return 0; fi
    fi
    
    # ä¼˜å…ˆçº§ 3: Sysfs
    [ ! -e "$_real_path" ] && return 1
    _bname="${_real_path##*/}"
    if [ -r "/sys/class/block/$_bname/dev" ]; then
        read -r _id < "/sys/class/block/$_bname/dev"
        _id="${_id%% *}"
        if [ -n "$_id" ]; then printf '%s\n' "$_id"; return 0; fi
    fi
    
    # æœ€åçš„æ‰‹æ®µï¼šè·¯å¾„å“ˆå¸Œ
    printf '%s\n' "path_$_real_path"
    return 0
}

# è§£æ Trim è¾“å‡ºå­—èŠ‚æ•°
parse_trim_bytes() {
    local _str="$1" _val
    case "$_str" in
        *" bytes"*) 
            _val="${_str%% bytes*}"
            # ç§»é™¤éæ•°å­—å‰ç¼€
            _val="${_val##*[!0-9]}" 
            ;;
        *) 
            local _word _num=0 _clean
            for _word in $_str; do
                _clean="$_word"
                # æ¸…ç†å¸¸è§åç¼€å’Œæ ‡ç‚¹
                _clean="${_clean%:}"
                _clean="${_clean%;}"
                _clean="${_clean%,}"
                _clean="${_clean%bytes}"
                _clean="${_clean%B}"
                
                case "$_clean" in 
                    ''|*[!0-9]*) continue ;; 
                    *) 
                        # é˜²å¾¡æ€§æ£€æŸ¥ï¼šé˜²æ­¢32ä½æ•´æ•°æº¢å‡ºï¼ˆæœ€å¤§å€¼ 2147483647 = 10ä½ï¼‰
                        if [ "${#_clean}" -le 10 ]; then
                            # 32ä½å®‰å…¨èŒƒå›´ï¼šå®‰å…¨æ¯”è¾ƒ
                            if [ "$_clean" -gt "$_num" ] 2>/dev/null; then
                                _num="$_clean"
                            fi
                        elif [ "${#_clean}" -le 15 ]; then
                            # å¤§æ•°å­—ç›´æ¥é‡‡ç”¨ï¼ˆå‡å®šä¸ºçœŸå®å­—èŠ‚æ•°ï¼‰
                            _num="$_clean"
                        fi
                        # è¶…è¿‡15ä½ï¼šä¸¢å¼ƒï¼ˆå¯èƒ½æ˜¯å¼‚å¸¸è¾“å‡ºï¼‰
                    ;;
                esac
            done
            _val="$_num" ;;
    esac
    is_integer "$_val" && printf '%s\n' "$_val" || printf '%s\n' "0"
}

# ==============================================================================
# execute_trim_robust (æ™ºèƒ½è§£åŒ… + å¤šçº§å›é€€)
# ==============================================================================
execute_trim_robust() {
    local _mnt="$1" _out="" _ret=1
    
    # ç»“æœæœ‰æ•ˆæ€§æ ¡éªŒ
    _is_valid() {
        local _r="$1" _o="$2"
        [ "$_r" -eq 0 ] && return 0
        case "$_o" in
            *"bytes"*|*"trimmed"*|*"B "*|*" KB"*|*" MB"*) return 0 ;;
            "") return 0 ;;
        esac
        return 1
    }
    
    # ------------------------------------------------------
    # ä¼˜å…ˆçº§ 1: timeout + fstrim
    # ------------------------------------------------------
    if [ "$HAS_TIMEOUT" = true ] && [ "$HAS_FSTRIM" = true ]; then
        local _cmd_prefix="" _target_bin="fstrim" _type_out
        
        # è§£åŒ… fstrim (å¦‚æœæ˜¯ä»£ç†å‡½æ•°)
        _type_out=$(type fstrim 2>/dev/null)
        case "$_type_out" in
            *function*) 
                [ -n "$BB_PATH" ] && _target_bin="$BB_PATH fstrim" 
                ;;
        esac
        
        # è§£åŒ… timeout
        _type_out=$(type timeout 2>/dev/null)
        case "$_type_out" in
            *function*) 
                _cmd_prefix="$BB_PATH timeout $TRIM_TIMEOUT" 
                ;;
            *)
                _cmd_prefix="timeout $TRIM_TIMEOUT" 
                ;;
        esac
        
        # æ‰§è¡Œ (ä¸åŠ å¼•å·ï¼Œå…è®¸ç©ºæ ¼åˆ†è¯)
        if [ -n "$_cmd_prefix" ]; then
            _out=$($_cmd_prefix $_target_bin -v "$_mnt" 2>&1)
        else
            _out=$($_target_bin -v "$_mnt" 2>&1)
        fi
        _ret=$?
        
        if _is_valid "$_ret" "$_out"; then
            printf '%s\n' "$_out"
            return 0
        fi
        
        # å¤±è´¥è¯Šæ–­
        log_msg "        â”œâ”€ âš ï¸ timeout+fstrim å¤±è´¥ - é€€å‡ºç : $_ret"
        [ -n "$_out" ] && log_msg "        â”‚        â””â”€ è¾“å‡º: $_out"
    fi
    
    # ------------------------------------------------------
    # ä¼˜å…ˆçº§ 2: fstrim ç›´æ¥è°ƒç”¨
    # ------------------------------------------------------
    if [ "$HAS_FSTRIM" = true ]; then
        _out=$(fstrim -v "$_mnt" 2>&1)
        _ret=$?
        
        if _is_valid "$_ret" "$_out"; then
            printf '%s\n' "$_out"
            return 0
        fi
        
        log_msg "        â”œâ”€ âš ï¸ fstrim å¤±è´¥ - é€€å‡ºç : $_ret"
        [ -n "$_out" ] && log_msg "        â”‚        â””â”€ è¾“å‡º: $_out"
    fi
    
    # ------------------------------------------------------
    # ä¼˜å…ˆçº§ 3: Busybox fstrim è£¸è°ƒ
    # ------------------------------------------------------
    if [ -n "$BB_PATH" ]; then
        _out=$("$BB_PATH" fstrim -v "$_mnt" 2>&1)
        _ret=$?
        
        if _is_valid "$_ret" "$_out"; then
            printf '%s\n' "$_out"
            return 0
        fi
    fi
    
    # ------------------------------------------------------
    # ä¼˜å…ˆçº§ 4: sm fstrim (Android ä¸“ç”¨ï¼Œå…¨å±€ Trim)
    # ------------------------------------------------------
    if [ "$SM_FSTRIM_CALLED" = false ] && command -v sm >/dev/null 2>&1; then
        log_msg "        â”œâ”€ å°è¯• Android sm fstrim (å…¨å±€)..."
        _out=$(sm fstrim 2>&1)
        _ret=$?
        SM_FSTRIM_CALLED=true
        
        if [ "$_ret" -eq 0 ]; then
            log_msg "        â”‚        â””â”€ âœ… sm fstrim æˆåŠŸ (å·²å¤„ç†æ‰€æœ‰åˆ†åŒº)"
            printf '%s\n' "$_out"
            return 0
        fi
        
        log_msg "        â”‚        â””â”€ âš ï¸ sm fstrim å¤±è´¥ - é€€å‡ºç : $_ret"
        [ -n "$_out" ] && log_msg "        â”‚        â””â”€ è¾“å‡º: $_out"
    fi
    
    log_msg "        â””â”€ âŒ æ‰€æœ‰ Trim æ–¹æ³•å‡å¤±è´¥"
    printf '%s\n' "${_out:-[Trim ä¸å¯ç”¨]}"
    return 127
}



# ==============================================================================
# çŠ¶æ€æ£€æµ‹ä¸å¹¶å‘é”
# ==============================================================================

# å±å¹•çŠ¶æ€æ£€æµ‹ (åŠ¨æ€åˆå§‹åŒ–)
init_screen_check() {
    local _node _val

    # ç­–ç•¥ 1: DRM èŠ‚ç‚¹ (æœ€å¿«/æœ€å‡†)
    for _node in /sys/class/drm/card*/enabled; do
        [ -e "$_node" ] || continue
        [ -r "$_node" ] || continue
        read -r _val < "$_node" 2>/dev/null
        if [ "$_val" = "enabled" ] || [ "$_val" = "disabled" ]; then
            eval "is_screen_on() { read -r _v < \"$_node\" 2>/dev/null; [ \"\$_v\" = \"enabled\" ]; }"
            return 0
        fi
    done

    # ç­–ç•¥ 2: èƒŒå…‰äº®åº¦ (é€šç”¨)
    for _node in /sys/class/backlight/*/brightness; do
        [ -e "$_node" ] || continue
        [ -r "$_node" ] || continue
        read -r _val < "$_node" 2>/dev/null
        if is_integer "$_val"; then
            [ "$_val" -gt 0 ] && return 0
        fi
    done

    # ç­–ç•¥ 3: API çŠ¶æ€ (å›é€€)
    if command -v getprop >/dev/null 2>&1; then
        _val=$(getprop sys.display.state 2>/dev/null)
        if [ -n "$_val" ]; then
            is_screen_on() { 
                case "$(getprop sys.display.state 2>/dev/null)" in ON|DOZE) return 0 ;; *) return 1 ;; esac 
            }
            return 0
        fi
    fi

    # ç­–ç•¥ 4: Dumpsys (æœ€æ…¢ï¼Œä»…ä½œä¸ºæœ€åæ‰‹æ®µï¼Œä¸”é™åˆ¶é¢‘ç‡)
    _LAST_SCREEN_CHECK=0
    _LAST_SCREEN_STATE=1

    is_screen_on() {
        local _now
        _now=$(date +%s)
        if [ $((_now - _LAST_SCREEN_CHECK)) -lt 5 ]; then
            return $_LAST_SCREEN_STATE
        fi
        _LAST_SCREEN_CHECK=$_now
        if dumpsys power 2>/dev/null | {
            while IFS= read -r _line; do
                case "$_line" in
                    *"mWakefulness=Awake"*)
                        exit 0 
                        ;;
                esac
            done
            exit 1
        }; then
            _LAST_SCREEN_STATE=0
            return 0
        else
            _LAST_SCREEN_STATE=1
            return 1
        fi
    }
}

# åˆå§‹åŒ–å±å¹•æ£€æµ‹
init_screen_check

is_charging() {
    local _val _node
    if [ -f "/sys/class/power_supply/battery/status" ]; then
        read_first_line _val "/sys/class/power_supply/battery/status"
        case "$_val" in Charging|Full) return 0 ;; esac
    fi
    for _node in /sys/class/power_supply/*/online; do
        [ -e "$_node" ] || continue
        read_first_line _val "$_node"; [ "$_val" = "1" ] && return 0
    done
    return 1
}

acquire_lock() {
    if mkdir "$LOCK_DIR" 2>/dev/null; then echo "$$" > "$LOCK_PID_FILE"; return 0; fi
    if [ ! -s "$LOCK_PID_FILE" ]; then
        rm -rf "$LOCK_DIR" 2>/dev/null
        mkdir "$LOCK_DIR" 2>/dev/null && echo "$$" > "$LOCK_PID_FILE" && return 0
    fi
    local _pid _cmd
    read_first_line _pid "$LOCK_PID_FILE"
    if [ -n "$_pid" ] && [ -d "/proc/$_pid" ]; then
        read -r _cmd < "/proc/$_pid/cmdline" 2>/dev/null
        case "$_cmd" in
            *"$SCRIPT_NAME"*)
                return 1
                ;;
        esac
    fi
    rm -rf "$LOCK_DIR" 2>/dev/null
    mkdir "$LOCK_DIR" 2>/dev/null && echo "$$" > "$LOCK_PID_FILE"
}


cleanup() {
    local _code="${1:-$EXIT_CODE}"
    trap - EXIT TERM INT HUP QUIT ABRT
    
    # å°è¯•æ¸…ç†æ‰€æœ‰å­è¿›ç¨‹
    for _p in /proc/[0-9]*; do
        [ -d "$_p" ] || continue
        _p=${_p##*/}
        
        case "$_p" in *[!0-9]*) continue ;; esac

        [ "$_p" = "$$" ] && continue
        
        read -r _ _ _ _ppid _ < "/proc/$_p/stat" 2>/dev/null || continue
        [ "$_ppid" = "$$" ] && kill "$_p" 2>/dev/null
    done
    
    command -v pkill >/dev/null 2>&1 && pkill -P $$ >/dev/null 2>&1
    
    if [ "$HAS_ACQUIRED_WAKELOCK" = true ]; then echo "$WAKE_LOCK_ID" > /sys/power/wake_unlock 2>/dev/null; fi
    [ -n "$ACTIVE_GC_NODE" ] && echo "$RESTORE_GC_VAL" > "$ACTIVE_GC_NODE" 2>/dev/null
    [ -n "$ACTIVE_SLEEP_NODE" ] && echo "$RESTORE_SLEEP_VAL" > "$ACTIVE_SLEEP_NODE" 2>/dev/null
    
    rm -rf "$LOCK_DIR" 2>/dev/null
    
    if [ "$_code" -ne 0 ]; then log_msg "âŒ é€€å‡º (Code: $_code)"; fi
    exit "$_code"
}

# ==============================================================================
# æ‰§è¡Œé€»è¾‘
# ==============================================================================

do_system_action() {
    local _path="$1" _type="$2"
    if command -v sm >/dev/null 2>&1; then
        if [ "$_type" = "trim" ]; then
            sm fstrim >/dev/null 2>&1
        else
            sm idle-maint run >/dev/null 2>&1
            COUNT_SYS_API=$((COUNT_SYS_API + 1))
        fi
        return 0
    fi
    return 1
}

# æŸ¥æ‰¾ F2FS sysfs èŠ‚ç‚¹: ç›®å½•å > ç²¾ç¡®åŒ¹é… > æ¨¡ç³ŠåŒ¹é…
find_f2fs_node() {
    local _real_dev="$1" _bname="${1##*/}" _target_mm="" _iname
    if [ -r "/sys/class/block/$_bname/dev" ]; then
        read_first_line _target_mm "/sys/class/block/$_bname/dev"
        _target_mm="${_target_mm%% *}"
    fi
    # ä¼˜å…ˆçº§ 1: ç›®å½•å
    [ -d "/sys/fs/f2fs/$_bname" ] && { printf '%s\n' "/sys/fs/f2fs/$_bname"; return 0; }
    [ -d "/sys/fs/mifs/$_bname" ] && { printf '%s\n' "/sys/fs/mifs/$_bname"; return 0; }
    # ä¼˜å…ˆçº§ 2: ç²¾ç¡®åŒ¹é… dev_name
    for _base in /sys/fs/f2fs /sys/fs/mifs; do
        [ -d "$_base" ] || continue
        for _d in "$_base"/*; do
            [ -e "$_d" ] || continue
            [ -f "$_d/dev_name" ] || continue
            read_first_line _iname "$_d/dev_name"
            _iname="${_iname%% *}"
            [ "$_iname" = "$_bname" ] && { printf '%s\n' "$_d"; return 0; }
            [ "$_iname" = "/dev/block/$_bname" ] && { printf '%s\n' "$_d"; return 0; }
            if [ -n "$_target_mm" ]; then [ "$_iname" = "$_target_mm" ] && { printf '%s\n' "$_d"; return 0; }; fi
        done
    done
    # ä¼˜å…ˆçº§ 3: æ¨¡ç³ŠåŒ¹é…
    for _base in /sys/fs/f2fs /sys/fs/mifs; do
        [ -d "$_base" ] || continue
        for _d in "$_base"/*; do
            [ -e "$_d" ] || continue
            [ -f "$_d/dev_name" ] || continue
            read_first_line _iname "$_d/dev_name"
            case "$_iname" in 
                *"/${_bname}"|"${_bname}") printf '%s\n' "$_d"; return 0 ;; 
            esac
        done
    done
    return 1
}

process_target() {
    local _mnt="$1" _raw_dev="$2" _fstype="$3"
    local _real_dev _bname _node _is_healthy=false _s_dirty="0"
    
    _real_dev=$(resolve_dev_path "$_raw_dev")
    _bname="${_real_dev##*/}"
    _node=$(find_f2fs_node "$_real_dev")

    log_msg "â© ç›®æ ‡: $_mnt [$_fstype]"
    
    # è·å–è®¾å¤‡å·ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    local _dbg_mm=""
    if [ -r "/sys/class/block/$_bname/dev" ]; then
        read -r _dbg_mm < "/sys/class/block/$_bname/dev" 2>/dev/null
        _dbg_mm="${_dbg_mm%% *}"
    fi
    log_msg "        â”œâ”€ Dev: $_raw_dev -> $_bname [ID:${_dbg_mm:-Unknown}]"

    if [ -n "$_node" ] && [ -f "$_node/dirty_segments" ]; then
        read_first_line _s_dirty "$_node/dirty_segments"
        if is_integer "$_s_dirty" && [ "$_s_dirty" -lt "$GC_DIRTY_MIN" ]; then _is_healthy=true; fi
    fi

    # Trim æ‰§è¡Œé€»è¾‘
    if [ "$TRIM" = true ]; then
        if [ "$STOP_ON_SCREEN_ON" = true ] && is_screen_on; then
            log_msg "        â”œâ”€ Trim: ğŸš« è·³è¿‡(äº®å±)"
            COUNT_SCREEN_SKIP=$((COUNT_SCREEN_SKIP + 1))
        elif [ "$ENABLE_SMART_TRIM" = true ] && [ "$_is_healthy" = true ]; then
            log_msg "        â”œâ”€ Trim: ğŸ’¤ è·³è¿‡(å¥åº·|Dirty:$_s_dirty)"
            COUNT_TRIM_SKIP=$((COUNT_TRIM_SKIP + 1))
        elif [ "$USE_SYSTEM_API" = true ]; then
            do_system_action "$_mnt" "trim"
            log_msg "        â”œâ”€ Trim: âš ï¸ ç³»ç»Ÿæ‰˜ç®¡(å¼ºåˆ¶)"
        else
            # åŒæ­¥è„æ•°æ®
            log_msg "        â”œâ”€ æ­£åœ¨åŒæ­¥ç£ç›˜ç¼“å­˜ (sync)..."
            
            # åå° sync å¹¶è¶…æ—¶ç›‘æ§
            sync &
            local _sync_pid=$!
            local _wait=0
            while kill -0 "$_sync_pid" 2>/dev/null; do
                sleep 1
                _wait=$((_wait + 1))
                if [ "$_wait" -ge 60 ]; then
                    log_msg "        â”œâ”€ âš ï¸ Sync è¶…æ—¶ (60s)ï¼Œè·³è¿‡ç­‰å¾…"
                    break
                fi
            done
            
            local _out _ret _bytes _kb
            _out=$(execute_trim_robust "$_mnt")
            _ret=$?
            
            if [ "$_ret" -eq 0 ] 2>/dev/null; then
                COUNT_TRIM_RUN=$((COUNT_TRIM_RUN + 1))
                _bytes=$(parse_trim_bytes "$_out")
                
                if [ "$_bytes" -gt 0 ] 2>/dev/null; then
                    _kb=$(( (_bytes + 1023) / 1024 ))
                    if [ ${#TOTAL_TRIM_KB} -le 9 ] 2>/dev/null; then
                        TOTAL_TRIM_KB=$((TOTAL_TRIM_KB + _kb))
                    fi
                    log_msg "        â”œâ”€ ç»“æœ: âœ… ${_kb} KB"
                else
                    # 0å­—èŠ‚æƒ…å†µï¼šè®°å½•å¹¶æ˜¾ç¤ºï¼ˆå¯èƒ½æ˜¯ discard/F2FS/SELinuxï¼‰
                    COUNT_TRIM_ZERO=$((COUNT_TRIM_ZERO + 1))
                    log_msg "        â”œâ”€ ç»“æœ: âœ… 0 B (æ— éœ€æ¸…ç†)"
                    [ -n "$_out" ] && log_msg "        â”‚        â””â”€ åŸå§‹: $_out"
                fi
            else
                # Trim å¤±è´¥ï¼šæ˜¾ç¤ºè¯¦ç»†é”™è¯¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
                log_msg "        â”œâ”€ Trim: âŒ æœ€ç»ˆå¤±è´¥ (é€€å‡ºç : $_ret)"
                [ -n "$_out" ] && log_msg "        â”‚        â””â”€ è¾“å‡º: $_out"
                
                if ! do_system_action "$_mnt" "trim"; then
                    LIST_FAIL="$LIST_FAIL $_mnt(Trim)"
                else
                    log_msg "        â”œâ”€ Trim: âš ï¸ ç³»ç»ŸAPIæ‰˜ç®¡ (è¡¥æ•‘æˆåŠŸ)"
                fi
            fi
        fi
    fi

    # GC æ‰§è¡Œé€»è¾‘
    if [ "$GC" = true ]; then
        case "$_fstype" in f2fs|mifs) ;; *) return 0 ;; esac
        
        local _ctrl=""
        if [ -n "$_node" ]; then
            [ -w "${_node}/gc_urgent_mode" ] && _ctrl="${_node}/gc_urgent_mode"
            [ -z "$_ctrl" ] && [ -w "${_node}/gc_urgent" ] && _ctrl="${_node}/gc_urgent"
        fi

        if [ "$USE_SYSTEM_API" = true ]; then
            do_system_action "$_mnt" "gc"
            log_msg "        â””â”€ GC:   âš ï¸ ç³»ç»Ÿæ‰˜ç®¡(å¼ºåˆ¶)"
            return
        fi

        if [ -z "$_ctrl" ]; then
            do_system_action "$_mnt" "gc"
            log_msg "        â””â”€ GC:   âš ï¸ ç³»ç»Ÿæ‰˜ç®¡(æ— æ¥å£)"
            return
        fi

        if [ "$ENABLE_SMART_GC" = true ] && [ "$_is_healthy" = true ]; then
            log_msg "        â””â”€ GC:   ğŸ’¤ è·³è¿‡(å¥åº·)"
            COUNT_GC_SKIP=$((COUNT_GC_SKIP + 1))
            return
        fi

        if [ "$STOP_ON_SCREEN_ON" = true ] && is_screen_on; then
            log_msg "        â””â”€ GC:   ğŸš« è·³è¿‡(äº®å±)"
            COUNT_SCREEN_SKIP=$((COUNT_SCREEN_SKIP + 1))
            return 0
        fi

        COUNT_GC_RUN=$((COUNT_GC_RUN + 1))
        sync
        
        # è·å–å”¤é†’é”
        echo "$WAKE_LOCK_ID" > /sys/power/wake_lock 2>/dev/null
        HAS_ACQUIRED_WAKELOCK=true
        
        # ä¿å­˜GCåŸå§‹å€¼ï¼ˆå…¨å±€å˜é‡ï¼Œç”¨äºcleanupæ¢å¤ï¼‰
        read_first_line RESTORE_GC_VAL "$_ctrl"
        
        # çŠ¶æ€è‡ªæ„ˆï¼šé˜²æ­¢è¿›å…¥æ°¸ä¹… GC çš„æ­»å¾ªç¯
        # æ­£å¸¸å€¼åº”è¯¥æ˜¯ 0ï¼Œä»»ä½•é 0 å€¼éƒ½è§†ä¸ºå¼‚å¸¸æ®‹ç•™
        case "$RESTORE_GC_VAL" in 
            0|"") 
                # æ­£å¸¸çŠ¶æ€ï¼ˆ0 æˆ–ç©ºï¼‰ï¼Œæ— éœ€é‡ç½®
                RESTORE_GC_VAL="0"
                ;;
            *[!0-9]*) 
                # å­—ç¬¦ä¸²å€¼ï¼ˆå¦‚ GC_URGENT_HIGHï¼‰
                log_msg "      âš ï¸ æ£€æµ‹åˆ°å¼‚å¸¸æ®‹ç•™çŠ¶æ€ [${RESTORE_GC_VAL}]ï¼Œå·²é‡ç½®ä¸º 0"
                RESTORE_GC_VAL="0" 
                ;;
            *) 
                # é 0 æ•°å­—ï¼ˆå¦‚ 1/2/3/5ï¼‰
                log_msg "      âš ï¸ æ£€æµ‹åˆ°å¼‚å¸¸æ®‹ç•™çŠ¶æ€ [${RESTORE_GC_VAL}]ï¼Œå·²é‡ç½®ä¸º 0"
                RESTORE_GC_VAL="0" 
                ;;
        esac
        
        ACTIVE_GC_NODE="$_ctrl"
        
        # Turbo GCï¼šå°è¯•è®¾ç½® sleep_timeï¼ˆå¯é€‰ï¼Œå¤±è´¥ä¸å½±å“GCï¼‰
        if [ "$ENABLE_TURBO_GC" = true ] && [ -f "$_node/gc_urgent_sleep_time" ]; then
            local _snode="$_node/gc_urgent_sleep_time"
            read_first_line RESTORE_SLEEP_VAL "$_snode"
            
            # çœŸå®å†™å…¥æµ‹è¯•ï¼ˆé¿å… -w è¯¯åˆ¤ï¼‰
            if echo "$GC_TURBO_SLEEP" > "$_snode" 2>/dev/null; then
                ACTIVE_SLEEP_NODE="$_snode"
            else
                # æƒé™ä¸è¶³æ—¶è®°å½•å¹¶ç»§ç»­ï¼ˆä½¿ç”¨å†…æ ¸é»˜è®¤å€¼ï¼‰
                log_msg "      âš ï¸ sleep_time ä¸å¯å†™ï¼Œä½¿ç”¨å†…æ ¸é»˜è®¤å€¼"
                RESTORE_SLEEP_VAL=""
            fi
        fi
        
        local _mode_ok=false
        echo "$GC_MODE_PREF" > "$_ctrl" 2>/dev/null && _mode_ok=true
        if [ "$_mode_ok" = false ]; then
             local _alt="2"; [ "$GC_MODE_PREF" = "2" ] && _alt="1"
             echo "$_alt" > "$_ctrl" 2>/dev/null && _mode_ok=true
        fi

        if [ "$_mode_ok" = false ]; then
            ACTIVE_GC_NODE=""; RESTORE_GC_VAL=""; ACTIVE_SLEEP_NODE=""; RESTORE_SLEEP_VAL=""
            echo "$WAKE_LOCK_ID" > /sys/power/wake_unlock 2>/dev/null
            HAS_ACQUIRED_WAKELOCK=false
            log_msg "        â””â”€ GC:   âŒ æ¿€æ´»å¤±è´¥ -> ç³»ç»Ÿæ‰˜ç®¡"
            do_system_action "$_mnt" "gc"
            return
        fi
        
        log_msg "        â””â”€ GC:   ğŸš€ GCå›æ”¶ä¸­ï¼Œè¯·è€å¿ƒç­‰å¾…å›æ”¶å®Œæ¯•... (Dirty: $_s_dirty)"
        
        # [è°ƒè¯•] è®°å½•GCå‚æ•°ï¼ˆæ˜¾ç¤ºå†™å…¥å€¼ï¼Œé¿å…å†…æ ¸æšä¸¾æ··æ·†ï¼‰
        local _set_mode="$GC_MODE_PREF"
        local _set_sleep="${GC_TURBO_SLEEP:-é»˜è®¤}"
        local _act_mode="" _act_sleep=""
        
        # [è°ƒè¯•] è¯»å–å†…æ ¸å®é™…å€¼ä½œä¸ºå‚è€ƒ
        read_first_line _act_mode "$_ctrl"
        [ -n "$ACTIVE_SLEEP_NODE" ] && read_first_line _act_sleep "$ACTIVE_SLEEP_NODE"
        
        # ä¸»æ—¥å¿—ï¼šæ˜¾ç¤ºè„šæœ¬è®¾ç½®å€¼
        if [ -n "$ACTIVE_SLEEP_NODE" ]; then
            log_msg "        â””â”€ å‚æ•°: Mode=${_set_mode}, Sleep=${_set_sleep}ms"
        else
            log_msg "        â””â”€ å‚æ•°: Mode=${_set_mode}, Sleep=å†…æ ¸é»˜è®¤"
        fi
        
        # [è°ƒè¯•] å†…æ ¸å€¼ä¸è®¾ç½®å€¼ä¸åŒæ—¶æ˜¾ç¤º
        if [ -n "$_act_mode" ] && [ "$_act_mode" != "$_set_mode" ]; then
            log_msg "                 â””â”€ å†…æ ¸å®é™…: Mode=$_act_mode"
        fi
        
        # GC è½®è¯¢å¾ªç¯
        local _interrupted=false _read_success=false _prev_cur
        local _time=0 _cur=$_s_dirty _stable=0 _last=$_s_dirty
        
        while [ "$_time" -lt "$GC_MAX_SEC" ]; do
            if [ "$STOP_ON_SCREEN_ON" = true ] && is_screen_on; then 
                 log_msg "      âš ï¸ äº®å±ä¸­æ–­"
                 COUNT_SCREEN_SKIP=$((COUNT_SCREEN_SKIP + 1))
                 _interrupted=true
                 break
            fi
            
            sleep "$GC_POLL"
            [ -f "$_node/dirty_segments" ] || break
            
            _prev_cur=$_cur
            if read_first_line _cur "$_node/dirty_segments" && is_integer "$_cur"; then
                _read_success=true
                if [ "$_cur" -lt "$_last" ]; then 
                    _stable=0
                    _last=$_cur
                else 
                    _stable=$((_stable + 1))
                fi
            else
                _cur=$_prev_cur
            fi
            
            if [ "$_stable" -ge "$GC_STABLE_CNT" ]; then break; fi
            _time=$((_time + 1))
        done

        [ -n "$RESTORE_GC_VAL" ] && echo "$RESTORE_GC_VAL" > "$ACTIVE_GC_NODE" 2>/dev/null
        [ -n "$RESTORE_SLEEP_VAL" ] && echo "$RESTORE_SLEEP_VAL" > "$ACTIVE_SLEEP_NODE" 2>/dev/null
        echo "$WAKE_LOCK_ID" > /sys/power/wake_unlock 2>/dev/null
        HAS_ACQUIRED_WAKELOCK=false
        ACTIVE_GC_NODE=""; ACTIVE_SLEEP_NODE=""
        
        # ç»Ÿè®¡ç»“æœï¼ˆä»…åœ¨æˆåŠŸè¯»å–æ—¶è®¡ç®—ï¼‰
        if [ "$_interrupted" = false ]; then
            if [ "$_read_success" = true ] && is_integer "$_cur" && is_integer "$_s_dirty"; then
                local _diff=$((_s_dirty - _cur))
                if [ "$_diff" -gt 0 ]; then
                    TOTAL_GC_SEGS=$((TOTAL_GC_SEGS + _diff))
                    log_msg "        â””â”€ ç»“æœ: âœ… æ¸…ç† $_diff æ®µ"
                else
                    log_msg "        â””â”€ ç»“æœ: â¤ æ— å˜åŒ– (åˆå§‹:$_s_dirty -> ç»“æŸ:$_cur)"
                fi
            else
                log_msg "        â””â”€ ç»“æœ: âš ï¸ è¯»å–å¤±è´¥ï¼Œæ— æ³•ç»Ÿè®¡"
            fi
        else
            log_msg "        â””â”€ ç»“æœ: âš ï¸ ä¸­æ–­"
        fi
    fi
}

# ==============================================================================
# ä¸»æµç¨‹
# ==============================================================================

if ! acquire_lock; then
    _pid=""; read_first_line _pid "$LOCK_PID_FILE"
    log_msg "âŒ é”å†²çª (PID: $_pid)"; exit 1
fi
log_msg "âœ… é”å·²è·å– (PID: $$)"

# [è‡ªæˆ‘ä¿®å¤] æ¸…ç†å¯èƒ½æ®‹ç•™çš„å”¤é†’é” (é˜²æ­¢ä¸Šæ¬¡å¼‚å¸¸é€€å‡ºå¯¼è‡´æ— æ³•ä¼‘çœ )
echo "$WAKE_LOCK_ID" > /sys/power/wake_unlock 2>/dev/null

trap 'cleanup' EXIT TERM INT HUP QUIT ABRT

if [ "$(id -u)" -ne 0 ]; then
    log_msg "âŒ éœ€è¦ Root æƒé™"
    exit 1
fi

log_msg "=== f2fsopt å¯åŠ¨ ==="

# æ£€æµ‹æ¨¡å—çŠ¶æ€ï¼ˆç¦ç”¨/å¸è½½/æ›´æ–°ï¼‰
if [ -f "$MODDIR/disable" ] || [ -f "$MODDIR/remove" ] || [ -f "$MODDIR/update" ]; then
    log_msg "âš ï¸ æ£€æµ‹åˆ°æ¨¡å—æ“ä½œæ ‡è®°ï¼Œè·³è¿‡æ‰§è¡Œ"
    cleanup 0
fi

# OOM ä¿æŠ¤
if echo "-900" > /proc/self/oom_score_adj 2>/dev/null; then
    : # é™é»˜æˆåŠŸ
fi

# å……ç”µçŠ¶æ€æ£€æŸ¥
if [ "$ONLY_CHARGING" = true ] && ! is_charging; then
    log_msg "ğŸ”‹ æœªå……ç”µï¼Œè·³è¿‡æ‰§è¡Œ"
    cleanup 2
fi

# å±å¹•çŠ¶æ€æ£€æŸ¥
if [ "$STOP_ON_SCREEN_ON" = true ] && is_screen_on; then
    log_msg "ğŸ“± äº®å±ä¸­ï¼Œè·³è¿‡æ‰§è¡Œ"
    cleanup 2
fi

if [ -n "$MANUAL_TARGETS" ]; then
    log_msg "ğŸ¯ æ‰‹åŠ¨æ¨¡å¼ (æŒ‡å®šè·¯å¾„)"
    
    # æ”¶é›†æ‰‹åŠ¨æŒ‡å®šè·¯å¾„çš„è®¾å¤‡ä¿¡æ¯
    _unique_ids=""
    _manual_count=0
    
    for _m_target in $MANUAL_TARGETS; do
        # éªŒè¯è·¯å¾„å­˜åœ¨
        if [ ! -d "$_m_target" ]; then
            log_msg "   âŒ è·³è¿‡: $_m_target (ç›®å½•ä¸å­˜åœ¨)"
            continue
        fi
        
        # è§„èŒƒåŒ–è·¯å¾„
        _m_target="${_m_target%/}"
        [ -z "$_m_target" ] && _m_target="/"  # ä¿æŠ¤æ ¹åˆ†åŒº
        
        # ä» /proc/mounts æŸ¥æ‰¾æŒ‚è½½ä¿¡æ¯
        _m_found=false
        while read -r _m_dev _m_mnt _m_type _m_opts _m_rest; do
            _m_mnt=$(decode_path "$_m_mnt")
            _m_mnt="${_m_mnt%/}"
            [ -z "$_m_mnt" ] && _m_mnt="/"  # ä¿æŠ¤æ ¹åˆ†åŒº
            
            # ç²¾ç¡®åŒ¹é…æŒ‚è½½ç‚¹
            if [ "$_m_mnt" = "$_m_target" ]; then
                # éªŒè¯æ–‡ä»¶ç³»ç»Ÿç±»å‹
                case "$_m_type" in
                    f2fs|mifs|ext4)
                        # éªŒè¯æŒ‚è½½é€‰é¡¹
                        case "$_m_opts" in
                            *rw,*)
                                # è·å–è®¾å¤‡æŒ‡çº¹ï¼ˆç»Ÿä¸€å»é‡æœºåˆ¶ï¼‰
                                _m_fp=$(get_device_fingerprint "$_m_dev" "$_m_mnt")
                                if [ -n "$_m_fp" ]; then
                                    # æŒ‡çº¹å®‰å…¨åŒ–
                                    _id_safe="$_m_fp"
                                    while case "$_id_safe" in *[:/]*) true;; *) false;; esac; do
                                        case "$_id_safe" in
                                            *:*) _id_safe="${_id_safe%%:*}_${_id_safe#*:}" ;;
                                            */*) _id_safe="${_id_safe%%/*}_${_id_safe#*/}" ;;
                                        esac
                                    done
                                    
                                    _len=${#_m_mnt}
                                    eval "_recorded_len=\${_best_len_${_id_safe}:-99999}"
                                    
                                    # è‡ªåŠ¨é€‰æ‹©æœ€çŸ­è·¯å¾„ï¼ˆåŒè®¾å¤‡å¤šä¸ªæŒ‚è½½ç‚¹ï¼‰
                                    if [ "$_len" -lt "$_recorded_len" ] 2>/dev/null; then
                                        eval "_best_len_${_id_safe}='$_len'"
                                        eval "_best_line_${_id_safe}='$_m_dev@@@$_m_mnt@@@$_m_type'"
                                        
                                        eval "_is_seen=\${_seen_${_id_safe}}"
                                        if [ -z "$_is_seen" ]; then
                                            _unique_ids="$_unique_ids $_id_safe"
                                            eval "_seen_${_id_safe}=1"
                                            log_msg "   âœ… $_m_target ($_m_type, $_m_dev)"
                                        else
                                            log_msg "   ğŸ”„ æ›´æ–°: $_m_target (è·¯å¾„æ›´çŸ­)"
                                        fi
                                    else
                                        log_msg "   âš ï¸ è·³è¿‡: $_m_target (å·²æœ‰æ›´çŸ­è·¯å¾„)"
                                    fi
                                    
                                    eval "_best_count_${_id_safe}=\$((\${_best_count_${_id_safe}:-0} + 1))"
                                    _manual_count=$((_manual_count + 1))
                                fi
                                _m_found=true
                                break
                                ;;
                            *)
                                log_msg "   âš ï¸ è·³è¿‡: $_m_target (åªè¯»æŒ‚è½½)"
                                _m_found=true
                                break
                                ;;
                        esac
                        ;;
                    *)
                        log_msg "   âš ï¸ è·³è¿‡: $_m_target (ä¸æ”¯æŒçš„æ–‡ä»¶ç³»ç»Ÿ: $_m_type)"
                        _m_found=true
                        break
                        ;;
                esac
            fi
        done < /proc/mounts
        
        if ! $_m_found; then
            log_msg "   âš ï¸ è·³è¿‡: $_m_target (æœªæ‰¾åˆ°æŒ‚è½½ä¿¡æ¯)"
        fi
    done
    
    # å¤„ç†æ”¶é›†åˆ°çš„è®¾å¤‡ï¼ˆæœ€çŸ­è·¯å¾„ä¼˜å…ˆï¼‰
    log_msg "ğŸ“‹ å®é™…å¤„ç† ${_manual_count} ä¸ªæŒ‡å®šè·¯å¾„"
    
    for _id in $_unique_ids; do
        eval "_line=\${_best_line_${_id}}"
        eval "_count=\${_best_count_${_id}}"
        
        if [ -n "$_line" ]; then
            _m_dev="${_line%%@@@*}"
            _rest="${_line#*@@@}"
            _m_mnt="${_rest%%@@@*}"
            _m_type="${_rest#*@@@}"
            
            if [ "$_count" -gt 1 ]; then
                log_msg "   ğŸ”— $_m_mnt (åˆå¹¶ $_count ä¸ªæŒ‚è½½ç‚¹)"
            fi
            process_target "$_m_mnt" "$_m_dev" "$_m_type"
        fi
    done
else
        log_msg "ğŸ” è‡ªåŠ¨æ‰«ææŒ‚è½½ç‚¹..."
    
    _unique_ids=""
    _scan_count=0 _skip_count=0
    _slow_mounts=""  # è®°å½•æ…¢é€ŸæŒ‚è½½ç‚¹
    _very_slow_count=0
    
    while read -r _dev _mnt _type _opts _rest; do
        # åŸºç¡€è¿‡æ»¤ï¼ˆä¼˜å…ˆï¼Œé¿å…æ— æ•ˆè®¡æ—¶ï¼‰
        case "$_dev" in /dev/block/*) ;; *) continue ;; esac
        case "$_type" in f2fs|mifs|ext4) ;; *) continue ;; esac
        case "$_opts" in *rw,*) ;; *) continue ;; esac
        
        # è·¯å¾„è§£ç 
        _mnt_decoded=$(decode_path "$_mnt")
        _mnt_decoded="${_mnt_decoded%/}"
        [ -z "$_mnt_decoded" ] && _mnt_decoded="/"  # ä¿æŠ¤æ ¹åˆ†åŒº
        
        # ç»Ÿä¸€é»‘åå•æ£€æŸ¥
        if is_path_ignored "$_mnt_decoded"; then
            _skip_count=$((_skip_count + 1))
            continue
        fi
        
        _scan_count=$((_scan_count + 1))
        
        # æ€§èƒ½ç›‘æ§ï¼šä»…è°ƒè¯•æ¨¡å¼å¯ç”¨ï¼Œä¸”ä»…å¯¹éœ€å¤„ç†çš„æŒ‚è½½ç‚¹è®¡æ—¶
        local _mount_start_ms=0
        [ "$DEBUG_SCAN" = "1" ] && _mount_start_ms=$(get_timestamp_ms)
        
        # è·å–è®¾å¤‡æŒ‡çº¹ (æ€§èƒ½ç“¶é¢ˆç‚¹)
        _fingerprint=$(get_device_fingerprint "$_dev" "$_mnt_decoded")
        if [ -z "$_fingerprint" ]; then continue; fi
        
        # æŒ‡çº¹å®‰å…¨åŒ– (8:32 â†’ 8_32ï¼Œå¾ªç¯ç›´åˆ°ä¸åŒ…å«ç‰¹æ®Šå­—ç¬¦ : /)
        _id_safe="$_fingerprint"
        while case "$_id_safe" in *[:/]*) true;; *) false;; esac; do
            case "$_id_safe" in
                *:*) _id_safe="${_id_safe%%:*}_${_id_safe#*:}" ;;
                */*) _id_safe="${_id_safe%%/*}_${_id_safe#*/}" ;;
            esac
        done
        
        _len=${#_mnt_decoded}
        eval "_recorded_len=\${_best_len_${_id_safe}:-99999}"
        
        # æ›´æ–°æœ€çŸ­è·¯å¾„ (eval å˜é‡éœ€ä¿æŠ¤)
        if [ "$_len" -lt "$_recorded_len" ] 2>/dev/null; then
            eval "_best_len_${_id_safe}='$_len'"
            eval "_best_line_${_id_safe}='$_dev@@@$_mnt_decoded@@@$_type'"
            
            eval "_is_seen=\${_seen_${_id_safe}}"
            if [ -z "$_is_seen" ]; then
                 _unique_ids="$_unique_ids $_id_safe"
                 eval "_seen_${_id_safe}=1"
            fi
        fi
        
        eval "_best_count_${_id_safe}=\$((\${_best_count_${_id_safe}:-0} + 1))"
        
        # æ€§èƒ½ç›‘æ§ï¼šä»…è°ƒè¯•æ¨¡å¼ä¸‹è®¡ç®—è€—æ—¶
        if [ "$DEBUG_SCAN" = "1" ] && [ "$_mount_start_ms" -gt 0 ] 2>/dev/null; then
            local _mount_end_ms _mount_elapsed_ms
            _mount_end_ms=$(get_timestamp_ms)
            _mount_elapsed_ms=$((_mount_end_ms - _mount_start_ms))
            
            # æç«¯æ…¢é€Ÿ (>2ç§’)
            if [ "$_mount_elapsed_ms" -ge 2000 ] 2>/dev/null; then
                log_msg "   ğŸš¨ æç«¯æ…¢é€Ÿ: $_mnt_decoded (${_mount_elapsed_ms}ms)"
                _slow_mounts="$_slow_mounts$_mnt_decoded|${_mount_elapsed_ms}ms
"
                _very_slow_count=$((_very_slow_count + 1))
            # æ…¢é€Ÿ (>1.5ç§’)
            elif [ "$_mount_elapsed_ms" -ge "$VERY_SLOW_THRESHOLD" ] 2>/dev/null; then
                log_msg "   âš ï¸ æ…¢é€Ÿ: $_mnt_decoded (${_mount_elapsed_ms}ms) [ç±»å‹: $_type, è®¾å¤‡: $_dev]"
                _slow_mounts="$_slow_mounts$_mnt_decoded|${_mount_elapsed_ms}ms
"
                _very_slow_count=$((_very_slow_count + 1))
            # è¾ƒæ…¢ (>500ms)
            elif [ "$_mount_elapsed_ms" -ge "$SLOW_MOUNT_THRESHOLD" ] 2>/dev/null; then
                log_msg "   â±ï¸ è¾ƒæ…¢: $_mnt_decoded (${_mount_elapsed_ms}ms)"
            fi
        fi
        
    done < /proc/mounts

    log_msg "âš–ï¸ æ‰«æå®Œæˆ (å¤„ç†: ${_scan_count}, è·³è¿‡: ${_skip_count})"
    
    # æ€§èƒ½è¯Šæ–­æŠ¥å‘Š
    if [ "$DEBUG_SCAN" = "1" ] && [ "$_very_slow_count" -gt 0 ]; then
        log_msg "ğŸ“Š æ€§èƒ½è¯Šæ–­æŠ¥å‘Šï¼š"
        log_msg "   å‘ç° ${_very_slow_count} ä¸ªæ…¢é€ŸæŒ‚è½½ç‚¹ (>= ${VERY_SLOW_THRESHOLD}ms)"
        log_msg ""
        log_msg "   ğŸ” è¯¦ç»†åˆ—è¡¨ï¼š"
        printf '%s' "$_slow_mounts" | while IFS='|' read -r _slow_path _slow_time; do
            [ -n "$_slow_path" ] && log_msg "      - $_slow_path  [$_slow_time]"
        done
        log_msg ""
        log_msg "   ğŸ’¡ ä¼˜åŒ–å»ºè®®ï¼š"
        log_msg "      1. å°†ä»¥ä¸Šè·¯å¾„æ·»åŠ åˆ°é»‘åå•å˜é‡ IGNORE_PREFIXES"
        log_msg "      2. æ£€æŸ¥æ˜¯å¦ä¸ºè™šæ‹ŸæŒ‚è½½ç‚¹æˆ–ä¸å¿…è¦çš„åˆ†åŒº"
        log_msg ""
    fi
    
    # ç»“æœè¾“å‡ºä¸æ‰§è¡Œ
    for _id in $_unique_ids; do
        eval "_line=\${_best_line_${_id}}"
        eval "_count=\${_best_count_${_id}}"
        
        if [ -n "$_line" ]; then
            _dev="${_line%%@@@*}"
            _rest="${_line#*@@@}"
            _mnt="${_rest%%@@@*}"
            _type="${_rest#*@@@}"
            
            if [ "$_count" -gt 1 ]; then
                 log_msg "ğŸ”¸ $_mnt (ä¼˜é€‰è‡ª ${_count} ä¸ªæŒ‚è½½ç‚¹)"
            else
                 log_msg "ğŸ”¹ $_mnt"
            fi
            
            [ -n "$_mnt" ] && process_target "$_mnt" "$_dev" "$_type"
        fi
    done
fi
    
# ==============================================================================
# ç»Ÿè®¡æ‘˜è¦
# ==============================================================================

# è®¡ç®—è€—æ—¶
DURATION=$(( $(date +%s) - START_TIME ))
if [ "$DURATION" -lt 0 ] 2>/dev/null; then
    DURATION=0
    log_msg "âš ï¸ æ£€æµ‹åˆ°æ—¶é—´å¼‚å¸¸ï¼ˆå›æ‹¨ï¼‰ï¼Œè€—æ—¶å½’é›¶"
elif [ "$DURATION" -gt 86400 ] 2>/dev/null; then
    DURATION=86400
    log_msg "âš ï¸ æ£€æµ‹åˆ°æ—¶é—´å¼‚å¸¸ï¼ˆè¶…24å°æ—¶ï¼‰ï¼Œè€—æ—¶æˆªæ–­"
fi

if [ "$TOTAL_TRIM_KB" -gt 1048576 ]; then 
    _gb=$((TOTAL_TRIM_KB * 10 / 1024 / 1024))
    _int=$((_gb / 10))
    _dec=$((_gb % 10))
    SHOW_TRIM="${_int}.${_dec}GB"
elif [ "$TOTAL_TRIM_KB" -gt 1024 ]; then 
    SHOW_TRIM="$((TOTAL_TRIM_KB/1024))MB"
else 
    SHOW_TRIM="${TOTAL_TRIM_KB}KB"
fi

# ä¼˜åŒ– 0KB çš„æ˜¾ç¤ºé€»è¾‘
if [ "$TOTAL_TRIM_KB" -eq 0 ] 2>/dev/null; then
    if [ "$COUNT_TRIM_SKIP" -gt 0 ] 2>/dev/null; then
        # æ™ºèƒ½è·³è¿‡ï¼šçœŸæ­£å¥åº·
        SHOW_TRIM="ğŸ’¤å¥åº·"
    elif [ "$COUNT_TRIM_ZERO" -gt 0 ] 2>/dev/null; then
        # æ‰§è¡Œäº†ä½†è¿”å› 0 å­—èŠ‚ï¼ˆdiscard/F2FS/SELinuxï¼‰
        SHOW_TRIM="0B(æ— éœ€æ¸…ç†)"
    fi
fi

if [ "$TOTAL_GC_SEGS" -gt 0 ] 2>/dev/null; then
    SHOW_GC="${TOTAL_GC_SEGS}æ®µ"
    [ "$COUNT_SCREEN_SKIP" -gt 0 ] 2>/dev/null && SHOW_GC="${SHOW_GC} ğŸš«äº®å±"
elif [ "$COUNT_SCREEN_SKIP" -gt 0 ] 2>/dev/null; then
    SHOW_GC="ğŸš«äº®å±ä¿æŠ¤"
elif [ "$COUNT_GC_SKIP" -gt 0 ] 2>/dev/null; then
    SHOW_GC="ğŸ’¤å¥åº·"
elif [ "$COUNT_SYS_API" -gt 0 ] 2>/dev/null; then
    SHOW_GC="âš ï¸æ‰˜ç®¡"
elif [ "$COUNT_GC_RUN" -gt 0 ] 2>/dev/null; then
    SHOW_GC="â–æ— å˜åŒ–"
else
    SHOW_GC="æœªè¿è¡Œ"
fi

SUMMARY="ğŸ§¹Trim:${SHOW_TRIM} â™»ï¸GC:${SHOW_GC} â±ï¸è€—æ—¶:${DURATION}ç§’"
log_msg "=== æ‰§è¡Œå®Œæˆ ==="
log_msg "$SUMMARY"
update_magisk_ui "$SUMMARY"
cleanup 0
